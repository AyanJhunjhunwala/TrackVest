import React, { useState, useRef, useEffect } from 'react';
import { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } from "@google/generative-ai";
import { Button } from "./components/ui/button";
import { MessageSquare, X, Send, Search, ChevronRight, BarChart4, LineChart, Zap, Lightbulb, TrendingUp, Layers } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import Chart from "./components/ui/Chart";
import ComparisonChart from "./components/ui/ComparisonChart";
import { 
  formatPortfolioData, 
  createPortfolioSummaryText
} from './utils/portfolioDataFormatter';
import {
  fetchStockQuote,
  fetchCryptoQuote,
  fetchRealEstateData,
  fetchFinancialNews,
  getMarketIndices
} from './utils/financialDataProvider';
import {
  parseChartRequest,
  generateChartResponse
} from './utils/chartDataGenerator';
import { chartEmitter } from './hooks/useChartSubscription';
import { subscribeToStockUpdates, subscribeToComparisonUpdates } from './services/chartDataService';
import { createTestStockChart, createTestComparisonChart, createIntelligentChart } from './utils/directChartGenerator';

// Initialize Google Generative AI with API key (revert to original class)
const genAI = new GoogleGenerativeAI(localStorage.getItem('geminiApiKey') || "AIzaSyDJ7tT1DyZ4FnSWIc4UazjYL4gGCo6vN0Y");

// API endpoints for data fetching
const CRYPTO_PRICE_API = "https://api.coingecko.com/api/v3";

// Define function declarations for generating charts
const lineChartFunctionDeclaration = {
  name: 'create_line_chart',
  description: 'Creates a line chart for financial data with dates and values.',
  parameters: {
    type: "OBJECT",
    properties: {
      title: {
        type: "STRING",
        description: 'The title for the chart.',
      },
      xKey: {
        type: "STRING",
        description: 'The key for the x-axis, typically "date".',
      },
      yKey: {
        type: "STRING",
        description: 'The key for the y-axis, typically "value".',
      },
      data: {
        type: "ARRAY",
        description: 'Array of data points with date and value properties.',
        items: {
          type: "OBJECT",
          properties: {
            date: {
              type: "STRING",
              description: 'Date in YYYY-MM-DD format.'
            },
            value: {
              type: "NUMBER",
              description: 'Numerical value for the data point.'
            }
          }
        }
      }
    },
    required: ['title', 'xKey', 'yKey', 'data'],
  },
};

const comparisonChartFunctionDeclaration = {
  name: 'create_comparison_chart',
  description: 'Creates a multi-line chart comparing multiple assets over time.',
  parameters: {
    type: "OBJECT",
    properties: {
      title: {
        type: "STRING",
        description: 'The title for the chart.',
      },
      xKey: {
        type: "STRING",
        description: 'The key for the x-axis, typically "date".',
      },
      data: {
        type: "ARRAY",
        description: 'Array of data points with date and values for each asset.',
        items: {
          type: "OBJECT",
          properties: {
            date: {
              type: "STRING",
              description: 'Date in YYYY-MM-DD format.'
            },
          }
        }
      },
      series: {
        type: "ARRAY",
        description: 'Array of series configurations.',
        items: {
          type: "OBJECT",
          properties: {
            name: {
              type: "STRING",
              description: 'Name of the asset/series.'
            },
            dataKey: {
              type: "STRING",
              description: 'Property name in data objects for this series.'
            }
          }
        }
      }
    },
    required: ['title', 'xKey', 'data', 'series'],
  },
};

const barChartFunctionDeclaration = {
  name: 'create_bar_chart',
  description: 'Creates a bar chart given a title, labels, and corresponding values.',
  parameters: {
    type: "OBJECT",
    properties: {
      title: {
        type: "STRING",
        description: 'The title for the chart.',
      },
      labels: {
        type: "ARRAY",
        items: { type: "STRING" },
        description: 'List of labels for the data points (e.g., ["Q1", "Q2", "Q3"]).',
      },
      values: {
        type: "ARRAY",
        items: { type: "NUMBER" },
        description: 'List of numerical values corresponding to the labels.',
      },
    },
    required: ['title', 'labels', 'values'],
  },
};

const chartCache = new Map();

// Instead of the previous search hook, create a simple state manager for grounding results
const useGroundingSearch = () => {
  const [isSearching, setIsSearching] = useState(false);
  const [groundingData, setGroundingData] = useState(null);
  
  return { isSearching, setIsSearching, groundingData, setGroundingData };
};

// Predefined financial data prompts
const FINANCIAL_KNOWLEDGE = `
You have extensive knowledge about financial markets, including:

1. Stocks: Market trends, fundamental and technical analysis, major indices, earnings reports, trading strategies
2. Crypto: Blockchain technology, cryptocurrencies, DeFi, NFTs, market dynamics, regulations
3. Real Estate: Market trends, investment strategies, rental income, property valuation, REITs
4. General investment: Asset allocation, diversification, risk management, tax considerations

Use this knowledge to provide helpful, accurate information when asked about financial topics.
`;

// Fetch crypto data from CoinGecko API
const fetchTopCryptos = async (limit = 10) => {
  try {
    // Check localStorage cache first
    const cachedData = localStorage.getItem('cachedCryptoData');
    const cachedTime = localStorage.getItem('cachedCryptoTime');
    
    // If we have cached data and it's less than 15 minutes old, use it
    if (cachedData && cachedTime) {
      const cacheAge = Date.now() - parseInt(cachedTime);
      if (cacheAge < 15 * 60 * 1000) { // 15 minutes in milliseconds
        console.log('Using cached crypto data, age:', Math.round(cacheAge / 1000 / 60), 'minutes');
        return JSON.parse(cachedData);
      }
      console.log('Cached crypto data expired, fetching fresh data');
    }
    
    // Fetch fresh data
    const response = await fetch(`${CRYPTO_PRICE_API}/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=${limit}&page=1&sparkline=true`);
    const data = await response.json();
    
    const formattedData = data.map(coin => ({
      id: coin.id,
      symbol: coin.symbol.toUpperCase(),
      name: coin.name,
      image: coin.image || `https://assets.coincap.io/assets/icons/${coin.symbol.toLowerCase()}@2x.png`,
      current_price: coin.current_price,
      price_change_percentage_24h: coin.price_change_percentage_24h,
      market_cap: coin.market_cap,
      sparkline: coin.sparkline_in_7d?.price || []
    }));
    
    // Cache the result
    localStorage.setItem('cachedCryptoData', JSON.stringify(formattedData));
    localStorage.setItem('cachedCryptoTime', Date.now().toString());
    
    return formattedData;
  } catch (error) {
    console.error('Error fetching crypto data:', error);
    
    // Try to use cached data even if it's expired
    const cachedData = localStorage.getItem('cachedCryptoData');
    if (cachedData) {
      console.log('Using expired cached crypto data due to fetch error');
      return JSON.parse(cachedData);
    }
    
    return [];
  }
};

// Replace the Alpha Vantage API key reference
const POLYGON_API_KEY = localStorage.getItem('polygonApiKey') || "9h2tWR97GWuVzS5a27bqgC4JjhC3H1uv";

// Fetch stock data using Polygon grouped API instead of individual API calls
const fetchPopularStocks = async () => {
  // Popular tech and finance stocks
  const popularTickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'META', 'TSLA', 'JPM', 'V', 'NVDA', 'BAC'];
  
  try {
    // Check localStorage cache first
    const cachedData = localStorage.getItem('cachedStockData');
    const cachedTime = localStorage.getItem('cachedStockTime');
    
    // If we have cached data and it's less than 15 minutes old, use it
    if (cachedData && cachedTime) {
      const cacheAge = Date.now() - parseInt(cachedTime);
      if (cacheAge < 15 * 60 * 1000) { // 15 minutes in milliseconds
        console.log('Using cached stock data, age:', Math.round(cacheAge / 1000 / 60), 'minutes');
        return JSON.parse(cachedData);
      }
      console.log('Cached stock data expired, fetching fresh data');
    }
    
    // Use our fetchGroupedStockData function to get data for all stocks at once
    const { getApiDate } = await import('./hooks');
    const { fetchGroupedStockData } = await import('./fetchGroupedStocks');
    
    // Get the most recent market day
    const date = getApiDate();
    console.log(`Fetching popular stocks data for ${date}`);
    
    // Fetch data for popular tickers
    const groupedData = await fetchGroupedStockData(date, popularTickers);
    
    if (groupedData.error || !groupedData.stocks || groupedData.stocks.length === 0) {
      throw new Error(groupedData.error || "Failed to fetch stock data");
    }
    
    // Transform the data into the expected format
    const results = groupedData.stocks.map(stock => ({
      symbol: stock.symbol,
      name: getCompanyName(stock.symbol),
      price: stock.close.toFixed(2),
      change: stock.change.toFixed(2),
      changePercent: stock.changePercent.toFixed(2),
      isMock: false
    }));
    
    console.log(`Successfully fetched data for ${results.length} popular stocks`);
    
    // Cache the results
    localStorage.setItem('cachedStockData', JSON.stringify(results));
    localStorage.setItem('cachedStockTime', Date.now().toString());
    
    return results;
  } catch (error) {
    console.error('Error fetching stock data:', error);
    
    // Try to use cached data even if it's expired
    const cachedData = localStorage.getItem('cachedStockData');
    if (cachedData) {
      console.log('Using expired cached stock data due to fetch error');
      return JSON.parse(cachedData);
    }
    
    // Fallback to mock data if API fails and no cache is available
    return popularTickers.map(ticker => {
      const mockChange = (Math.random() * 6) - 3; // -3% to +3%
      const mockPrice = ticker === 'AAPL' ? 180 + mockChange : 
                       ticker === 'MSFT' ? 350 + mockChange : 
                       ticker === 'GOOGL' ? 140 + mockChange :
                       ticker === 'AMZN' ? 160 + mockChange :
                       ticker === 'META' ? 325 + mockChange :
                       ticker === 'TSLA' ? 250 + mockChange :
                       ticker === 'JPM' ? 170 + mockChange :
                       ticker === 'V' ? 230 + mockChange :
                       ticker === 'NVDA' ? 450 + mockChange :
                       /* BAC */ 35 + mockChange;
      
      return {
        symbol: ticker,
        name: getCompanyName(ticker),
        price: mockPrice.toFixed(2),
        change: mockChange.toFixed(2),
        changePercent: (mockChange / mockPrice * 100).toFixed(2),
        isMock: true // Mark as mock data since API failed
      };
    });
  }
};

// Get company name based on ticker
const getCompanyName = (ticker) => {
  const companies = {
    'AAPL': 'Apple Inc.',
    'MSFT': 'Microsoft Corporation',
    'GOOGL': 'Alphabet Inc.',
    'AMZN': 'Amazon.com Inc.',
    'META': 'Meta Platforms Inc.',
    'TSLA': 'Tesla Inc.',
    'JPM': 'JPMorgan Chase & Co.',
    'V': 'Visa Inc.',
    'NVDA': 'NVIDIA Corporation',
    'BAC': 'Bank of America Corp.'
  };
  
  return companies[ticker] || ticker;
};

// Define tab content animation variants
const tabContentVariants = {
  hidden: { opacity: 0, x: 10 },
  visible: { 
    opacity: 1, 
    x: 0, 
    transition: { 
      duration: 0.3,
      type: "spring",
      stiffness: 120
    }
  },
  exit: { 
    opacity: 0, 
    x: -10, 
    transition: { 
      duration: 0.2 
    } 
  }
};

// Define enhanced animations for stocks and crypto tabs
const enhancedTabVariants = {
  hidden: { 
    opacity: 0, 
    y: 20, 
    scale: 0.97 
  },
  visible: { 
    opacity: 1, 
    y: 0, 
    scale: 1,
    transition: { 
      type: "spring",
      damping: 15,
      stiffness: 100,
      duration: 0.5,
      when: "beforeChildren",
      staggerChildren: 0.08
    }
  },
  exit: { 
    opacity: 0, 
    y: -20,
    transition: { 
      duration: 0.3 
    }
  }
};

const cardItemVariants = {
  hidden: { 
    opacity: 0, 
    y: 20 
  },
  visible: { 
    opacity: 1, 
    y: 0,
    transition: { 
      type: "spring", 
      stiffness: 100,
      damping: 15
    }
  }
};

// Add a helper function to format message content with Markdown-like syntax
const formatMessageContent = (content) => {
  if (!content) return '';
  
  // Replace code blocks with styled versions
  let formattedContent = content.replace(/```([a-z]*)\n([\s\S]*?)\n```/g, (match, language, code) => {
    return `<div class="bg-gray-800 rounded-md p-3 my-2 overflow-x-auto">
      <pre class="text-xs text-gray-200 font-mono">${code}</pre>
    </div>`;
  });
  
  // Format inline code
  formattedContent = formattedContent.replace(/`([^`]+)`/g, '<code class="bg-gray-800 px-1 rounded text-xs text-gray-200 font-mono">$1</code>');
  
  // Format bold text
  formattedContent = formattedContent.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
  
  // Format italics
  formattedContent = formattedContent.replace(/\*([^*]+)\*/g, '<em>$1</em>');
  
  // Format lists
  formattedContent = formattedContent.replace(/^\s*[\-\*]\s+(.+)$/gm, '<li class="ml-4">• $1</li>');
  formattedContent = formattedContent.replace(/(<li.*<\/li>)\s*(<li.*<\/li>)/g, '<ul class="my-2">$1$2</ul>');
  
  // Format numbered lists
  formattedContent = formattedContent.replace(/^\s*(\d+)\.\s+(.+)$/gm, '<li class="ml-4">$1. $2</li>');
  
  // Format links
  formattedContent = formattedContent.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" class="text-blue-400 underline">$1</a>');
  
  // Handle paragraphs
  formattedContent = formattedContent.replace(/\n\n/g, '</p><p class="mb-2">');
  
  return `<p class="mb-2">${formattedContent}</p>`;
};

export default function GeminiChat({ darkMode, positions = [], realEstateHoldings = [], onAddInsight }) {
  const [isOpen, setIsOpen] = useState(false);
  const [messages, setMessages] = useState([
    { role: 'system', content: 'You are a helpful financial assistant powered by Gemini. You can provide information and insights about stocks, cryptocurrencies, and real estate investments.' },
    { role: 'assistant', content: 'Hello! I\'m your TrackVest assistant. Ask me about your portfolio, market data, or financial insights. I can also create charts that will appear in your Insights tab' }
  ]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [marketData, setMarketData] = useState(null);
  const [newsData, setNewsData] = useState([]);
  const [activeTab, setActiveTab] = useState('chat');
  const [showSearch, setShowSearch] = useState(false);
  const [webSearchEnabled, setWebSearchEnabled] = useState(false);
  const [cryptoData, setCryptoData] = useState([]);
  const [stockData, setStockData] = useState([]);
  const [isCryptoLoading, setIsCryptoLoading] = useState(false);
  const [isStockLoading, setIsStockLoading] = useState(false);
  const { isSearching, setIsSearching, groundingData, setGroundingData } = useGroundingSearch();
  const [searchInput, setSearchInput] = useState('');
  const messageEndRef = useRef(null);
  const inputRef = useRef(null);
  const searchInputRef = useRef(null);
  const [insights, setInsights] = useState([]);
  const [showIndicators, setShowIndicators] = useState({});
  const [selectedIndicators, setSelectedIndicators] = useState({});

  // Format portfolio data
  const portfolioData = formatPortfolioData(positions, realEstateHoldings);
  const portfolioSummaryText = createPortfolioSummaryText(portfolioData);

  // Fetch market data when component mounts
  useEffect(() => {
    async function loadMarketData() {
      try {
        const indices = await getMarketIndices();
        setMarketData(indices);
        
        const news = await fetchFinancialNews('general');
        setNewsData(news.slice(0, 3)); // Get top 3 news items
      } catch (error) {
        console.error('Error fetching market data:', error);
      }
    }
    
    loadMarketData();
  }, []);

  // Load Google CSE script
  useEffect(() => {
    // Add Google CSE script if not already added
    if (!document.querySelector('script[src*="cse.google.com"]')) {
      const script = document.createElement('script');
      script.async = true;
      script.src = "https://cse.google.com/cse.js?cx=b5c69d94063434ee6";
      
      // Set up global CSE configuration before loading the script
      window.__gcse = {
        parsetags: 'explicit',
        callback: function() {
          console.log("Google CSE initialized");
        }
      };
      
      // Add callback when script loads
      script.onload = () => {
        console.log("Google CSE script loaded successfully");
      };
      
      script.onerror = () => {
        console.error("Failed to load Google CSE script");
      };
      
      document.head.appendChild(script);
    }
  }, []);

  // Format market data for the AI prompt
  const getMarketDataText = () => {
    if (!marketData) return '';
    
    let text = '\n\nCurrent Market Data:\n';
    text += `S&P 500: ${marketData['S&P 500'].value.toFixed(2)} (${marketData['S&P 500'].percentChange > 0 ? '+' : ''}${marketData['S&P 500'].percentChange}%)\n`;
    text += `Dow Jones: ${marketData['Dow Jones'].value.toFixed(2)} (${marketData['Dow Jones'].percentChange > 0 ? '+' : ''}${marketData['Dow Jones'].percentChange}%)\n`;
    text += `Nasdaq: ${marketData['Nasdaq'].value.toFixed(2)} (${marketData['Nasdaq'].percentChange > 0 ? '+' : ''}${marketData['Nasdaq'].percentChange}%)\n`;
    text += `Bitcoin: $${marketData['Bitcoin'].value.toFixed(2)} (${marketData['Bitcoin'].percentChange > 0 ? '+' : ''}${marketData['Bitcoin'].percentChange}%)\n`;
    text += `Ethereum: $${marketData['Ethereum'].value.toFixed(2)} (${marketData['Ethereum'].percentChange > 0 ? '+' : ''}${marketData['Ethereum'].percentChange}%)\n`;
    
    return text;
  };

  // Format news data for the AI prompt
  const getNewsText = () => {
    if (!newsData.length) return '';
    
    let text = '\n\nRecent Financial News:\n';
    newsData.forEach((item, index) => {
      text += `${index + 1}. ${item.title}\n`;
    });
    
    return text;
  };

  useEffect(() => {
    const marketDataText = getMarketDataText();
    const newsText = getNewsText();
    
    setMessages([
      { 
        role: 'system', 
        content: `You are a helpful financial assistant for TrackVest users. You have access to the user's complete investment portfolio including stocks, crypto, and real estate and you can make charts:

${portfolioSummaryText}${marketDataText}${newsText}

${FINANCIAL_KNOWLEDGE}

IMPORTANT: You have real-time access to financial data. NEVER tell the user that you don't have access to real-time or current financial data. Instead, use the portfolio and market data provided above to answer their questions directly.

The portfolio data above contains the user's ACTUAL holdings. You must use this information when answering questions about their portfolio. For example:
- When they ask "How many shares of MSFT do I have?" - look at the actual data above
- When they ask about their real estate - provide details from the actual properties they own
- When they ask about their crypto - reference their actual cryptocurrency holdings

You can provide details about stocks, crypto, and real estate markets to enhance your responses, including:
- Current prices, market caps, and performance metrics
- Technical indicators and trend analysis
- Financial ratios and fundamentals 
- Market news and recent developments

When users ask about their specific investments:
- For stocks: Provide the symbol, quantity, current price, total value, and percentage of portfolio
- For crypto: Provide the symbol, amount, current price, total value, and percentage of portfolio
- For real estate: Provide property details, valuation, equity, mortgage, rental yield, and ROI when available

You can also generate interactive charts for users, but ONLY when they specifically request a chart or graph. 
Examples of chart requests:
- "Show me a chart for AAPL"
- "Create a graph of my portfolio"
- "Visualize the performance of MSFT"
- "Plot the comparison between GOOGL and AMZN"

When users ask about their portfolio:
1. Provide concise, accurate information directly from the portfolio data provided above
2. For performance questions, focus on values, changes, and percentages
3. Offer insights about asset allocation and diversification
4. Be specific about individual holdings when asked
5. Be friendly but professional

If users ask about importing or feeding in more data, remind them they can use the Import Portfolio button in the header to add their custom investment data.`
      },
      { role: 'assistant', content: 'Hello! I\'m your TrackVest assistant. Ask me about your portfolio, market data, or financial insights. I can also create charts that will appear in your Insights tab' }
    ]);
  }, [positions, realEstateHoldings, marketData, newsData]);

  // Auto-scroll to the bottom of messages
  useEffect(() => {
    messageEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  // Focus input when chat opens
  useEffect(() => {
    if (isOpen) {
      inputRef.current?.focus();
    }
  }, [isOpen]);

  // Fetch crypto data when component mounts or crypto tab is selected
  useEffect(() => {
    if (activeTab === 'crypto' && cryptoData.length === 0) {
      setIsCryptoLoading(true);
      fetchTopCryptos()
        .then(data => {
          setCryptoData(data);
          setIsCryptoLoading(false);
        })
        .catch(() => setIsCryptoLoading(false));
    }
  }, [activeTab, cryptoData.length]);

  // Fetch stock data when component mounts or stocks tab is selected
  useEffect(() => {
    if (activeTab === 'stocks' && stockData.length === 0) {
      setIsStockLoading(true);
      fetchPopularStocks()
        .then(data => {
          setStockData(data);
          setIsStockLoading(false);
        })
        .catch(() => setIsStockLoading(false));
    }
  }, [activeTab, stockData.length]);

  // Subscribe to chart updates from the chartEmitter
  useEffect(() => {
    // Function to handle chart updates
    const handleChartUpdate = (chartData) => {
      const { id, result, removed } = chartData;
      
      // Skip if essential data is missing
      if (!id) return;
      
      // Handle chart removal
      if (removed) {
        setInsights(prev => prev.filter(insight => insight.id !== id));
        return;
      }
      
      // Skip if no result data
      if (!result) return;
      
      setInsights(prev => {
        // Check if this chart already exists
        const exists = prev.some(insight => insight.id === id);
        if (exists) {
          // Update existing chart
          return prev.map(insight => 
            insight.id === id ? { ...insight, data: result, updatedAt: new Date() } : insight
          );
        } else {
          // Add new chart
          return [...prev, { 
            id, 
            data: result, 
            createdAt: new Date(),
            updatedAt: new Date()
          }];
        }
      });
    };

    // Subscribe to chart updates
    // The subscribe method returns the unsubscribe function directly
    const unsubscribe = chartEmitter.subscribe('*', handleChartUpdate);
    
    // Clean up subscription on unmount
    return unsubscribe;
  }, []); // Empty dependency array means this effect runs once on mount

  // Function to manually add a chart (avoids triggering the subscription)
  const addChart = (chartId, chartData) => {
    // Use direct chart emitter update rather than modifying state directly
    // This ensures the event flows through the proper channels
    chartEmitter.updateChart(chartId, chartData);
  };

  // Updated sendMessage function to use the new GoogleGenAI class structure
  const sendMessage = async () => {
    if (!input.trim()) return;
    
    const userMessage = { role: 'user', content: input };
    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);
    setGroundingData(null);

    try {
      // Get current portfolio data for directly including in each prompt
      const currentPortfolioSummaryText = createPortfolioSummaryText(formatPortfolioData(positions, realEstateHoldings));
      
      // Create the prompt
      const promptContent = `
        ${input}
        
        IMPORTANT: I'm providing you with the user's current portfolio data right now. You MUST use this information to answer questions about their holdings:
        
        ${currentPortfolioSummaryText}
        
        VERY IMPORTANT: 
        - You have real-time access to financial data. NEVER tell the user you don't have access to current market data.
        - For questions about metrics like P/E ratios, debt ratios, or financial indicators, provide the information directly.
        - Do not refer users to external websites for basic stock information or metrics.
        ${webSearchEnabled ? '- When you use search results, properly attribute the information with sources.' : ''}
        
        In your response, list ONLY stock ticker symbols that are explicitly mentioned in the query. Do not add any tickers that were not mentioned by the user.
        
        Format them exactly like this at the end of your response:
        TICKER_SYMBOLS: AAPL, MSFT, GOOGL
        
        Do NOT include square brackets, just use a comma-separated list.
        If no ticker symbols are mentioned, include "TICKER_SYMBOLS: NONE"
        Only include actual ticker symbols, not company names or other words.
        
        WHEN DISCUSSING THE USER'S PORTFOLIO:
        - If asked about specific stocks, check the portfolio data above and provide precise information including shares, value, etc.
        - If asked about specific cryptocurrencies, check the portfolio data above and provide precise information
        - If asked about real estate holdings, provide all relevant details like value, equity, mortgage, etc.
        - For any holdings NOT in the user's portfolio, clearly indicate this
        
        CHART CREATION RULES:
        - ONLY create charts when the user explicitly asks for a chart or graph
        - Do NOT extract ticker symbols for charts unless the user clearly wants a visualization
        - Example chart requests: "show me a chart for AAPL", "create a graph of my stocks", "visualize MSFT performance"
        - For general questions about holdings, just provide the text information, not charts
        
        If the user asks about importing or feeding in more data, explain they can use the "Import Portfolio" button in the header.
        
        Give me condensed outputs and properly formatted.
      `;

      // Create a Gemini model instance
      const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
      
      // Prepare config for search grounding if enabled
      const generationConfig = {};
      const safetySettings = [];
      
      // Configure tools array for search if enabled
      const tools = webSearchEnabled ? [{ googleSearch: {} }] : undefined;
      
      // Call the Gemini API with the original SDK structure
      const result = await model.generateContent({
        contents: [{ role: "user", parts: [{ text: promptContent }] }],
        generationConfig,
        safetySettings,
        tools
      });
      
      const response = result.response;
      const responseText = response.text();
      console.log("Gemini API response:", responseText);
      
      // Check for grounding metadata
      if (webSearchEnabled && response.candidates && 
          response.candidates[0].groundingMetadata) {
        
        // Store grounding data for rendering
        setGroundingData(response.candidates[0].groundingMetadata);
        
        // Log the rendered content for debugging
        if (response.candidates[0].groundingMetadata.searchEntryPoint?.renderedContent) {
          console.log("Search entry point:", 
            response.candidates[0].groundingMetadata.searchEntryPoint.renderedContent);
        }
        
        console.log("Grounding data:", response.candidates[0].groundingMetadata);
      }
      
      // Extract ticker symbols from response
      const tickerMatch = responseText.match(/TICKER_SYMBOLS:\s*(.*?)(?:\n|$)/);
      const tickerSymbols = tickerMatch ? 
        tickerMatch[1]
          .replace(/[\[\]]/g, '') // Remove any square brackets if present
          .split(',')
          .map(t => t.trim())
          .filter(t => t !== 'NONE' && t.length > 0)
        : [];
      
      console.log("Extracted tickers:", tickerSymbols);
      
      // Clean response to remove the TICKER_SYMBOLS line
      const cleanResponse = responseText.replace(/TICKER_SYMBOLS:.*?(\n|$)/g, '').trim();
      
      // Create an assistant message with the response
      const assistantMessage = { 
        role: 'assistant', 
        content: cleanResponse,
        groundingData: groundingData // Store grounding data with the message
      };
      setMessages(prev => [...prev, assistantMessage]);
      
      // Determine if a chart was actually requested
      const chartRequestKeywords = ['chart', 'graph', 'plot', 'visualize', 'visualization', 'show me'];
      const containsChartRequest = chartRequestKeywords.some(keyword => 
        input.toLowerCase().includes(keyword)
      );
      
      // Only create charts if explicitly requested and we have ticker symbols
      if (containsChartRequest && tickerSymbols.length > 0) {
        // Check for comparison intent by looking for comparison words
        const isComparison = input.toLowerCase().includes('compar') || 
                            input.toLowerCase().includes('versus') || 
                            input.toLowerCase().includes(' vs ') ||
                            input.toLowerCase().includes(' vs. ');
        
        const timeframeMatch = input.match(/\b(\d+[dwmy])\b/i);
        const timeframe = timeframeMatch ? timeframeMatch[1].toLowerCase() : '1m';
        
        try {
          // Use the unified intelligent chart function that handles both single and comparison charts
          // and automatically detects indicators from the user query
          console.log(`Creating intelligent chart for ${tickerSymbols.length} symbols using original query`);
          
          // Generate chart ID
          const chartId = isComparison ? 
            `comparison_${Date.now()}` : 
            `stock_${tickerSymbols[0]}_${Date.now()}`;
          
          // Create chart using the intelligent function
          const chartData = await createIntelligentChart(
            isComparison ? tickerSymbols : tickerSymbols[0], 
            input, // Pass original user query for intent analysis
            timeframe
          );
          
          // Add to chart system via emitter
          chartEmitter.updateChart(chartId, chartData);
          
          const chartMessage = { 
            role: 'assistant', 
            content: `I've added ${isComparison ? 'a comparison chart' : 'charts'} for ${tickerSymbols.join(', ')} to your Insights tab.`
          };
          setMessages(prev => [...prev, chartMessage]);
        } catch (chartError) {
          console.error("Error creating chart:", chartError);
          const chartErrorMessage = { 
            role: 'assistant', 
            content: `I tried to create a chart, but encountered an error. This might be due to API limitations.`
          };
          setMessages(prev => [...prev, chartErrorMessage]);
        }
      }
    } catch (error) {
      console.error('Error communicating with Gemini API:', error);
      
      // Add error message
      const errorMessage = { 
        role: 'assistant', 
        content: `I'm sorry, I encountered an error while processing your request. Please try again in a moment.`
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
    }
  };

  // Animation variants
  const buttonVariants = {
    initial: { scale: 1 },
    hover: { scale: 1.03 },
    tap: { scale: 0.97 }
  };
  
  const containerVariants = {
    hidden: { opacity: 0, y: -20 },
    visible: { 
      opacity: 1, 
      y: 0,
      transition: { 
        type: "spring", 
        damping: 25, 
        stiffness: 400,
        duration: 0.4 
      }
    },
    exit: { 
      opacity: 0, 
      y: -30, 
      transition: { duration: 0.2 } 
    }
  };

  // Render a message with improved UI
  const renderMessage = (message, index) => {
    const isUser = message.role === 'user';
    
    return (
      <motion.div 
        key={index}
        initial={{ opacity: 0, y: 10 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.3, delay: 0.1 * (index % 3) }}
        className={`p-4 my-3 rounded-2xl shadow-sm ${
          isUser 
          ? `${darkMode ? 'bg-blue-600 bg-gradient-to-br from-blue-500 to-blue-700' : 'bg-blue-500 bg-gradient-to-br from-blue-400 to-blue-600'} text-white ml-auto` 
          : `${darkMode ? 'bg-slate-800 border border-slate-700 bg-gradient-to-br from-slate-800 to-slate-900' : 'bg-white border border-slate-200 bg-gradient-to-br from-slate-50 to-white'} ${darkMode ? 'text-white' : 'text-slate-800'}`
        } ${isUser ? 'max-w-[80%]' : 'max-w-[90%]'}`}
      >
        <div className="mb-1 flex items-center">
          <div className={`w-7 h-7 mr-2 rounded-full flex items-center justify-center ${
            isUser ? (darkMode ? 'bg-blue-400' : 'bg-blue-400') : (darkMode ? 'bg-emerald-600' : 'bg-emerald-500')
          }`}>
            <span className="text-xs text-white font-bold">
              {isUser ? 'Y' : 'AI'}
            </span>
          </div>
          <span className={`text-xs font-medium ${isUser ? 'text-blue-200' : darkMode ? 'text-slate-400' : 'text-slate-500'}`}>
            {isUser ? 'You' : 'TrackVest AI'}
          </span>
        </div>
        
        <div 
          className="ml-8 text-sm leading-relaxed font-light message-content"
          dangerouslySetInnerHTML={{ __html: isUser ? message.content : formatMessageContent(message.content) }}
        />
        
        {/* Render grounding sources if available */}
        {!isUser && message.groundingData && (
          <div className="mt-4 ml-8 rounded-lg overflow-hidden">
            {/* Grounding chunks with improved styling */}
            {message.groundingData.groundingChunks && message.groundingData.groundingChunks.length > 0 && (
              <div className={`p-3 ${darkMode ? 'bg-slate-700 bg-opacity-40' : 'bg-blue-50'} rounded-t-lg border-b ${darkMode ? 'border-slate-600' : 'border-blue-100'}`}>
                <div className={`text-xs font-medium mb-2 ${darkMode ? 'text-blue-300' : 'text-blue-600'} flex items-center`}>
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3 mr-1" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M18 8a6 6 0 01-7.743 5.743L10 14l-1 1-1 1H6v-1l1-1-1-1H3v-1l2-2a1 1 0 011-1h2a9 9 0 019-9zm-1 5v1a5 5 0 01-5 5H7.258l-3-3H6v-1l.244-.244A5.984 5.984 0 016 10a6 6 0 019-6 6 6 0 012.973 11zm-1-2h-1a1 1 0 01-1-1V8a1 1 0 011-1h1a1 1 0 011 1v2a1 1 0 01-1 1z" clipRule="evenodd" />
                  </svg>
                  SOURCES
                </div>
                <div className="flex flex-wrap gap-2">
                  {message.groundingData.groundingChunks.map((chunk, i) => (
                    <a 
                      key={i}
                      href={chunk.web?.uri || '#'} 
                      target="_blank"
                      rel="noopener noreferrer"
                      className={`text-xs px-3 py-1.5 rounded-full flex items-center ${
                        darkMode ? 'bg-slate-600 hover:bg-slate-500 text-white' : 'bg-white hover:bg-blue-50 text-blue-700 border border-blue-200'
                      } transition-colors duration-150`}
                    >
                      <span className={`w-3 h-3 rounded-full mr-1.5 ${darkMode ? 'bg-blue-400' : 'bg-blue-500'}`}></span>
                      {chunk.web?.title || `Source ${i+1}`}
                    </a>
                  ))}
                </div>
              </div>
            )}
            
            {/* Web search queries with improved styling */}
            {message.groundingData.webSearchQueries && message.groundingData.webSearchQueries.length > 0 && (
              <div className={`p-3 ${darkMode ? 'bg-slate-700 bg-opacity-20' : 'bg-gray-50'} rounded-b-lg`}>
                <div className={`text-xs font-medium mb-2 ${darkMode ? 'text-slate-400' : 'text-slate-500'} flex items-center`}>
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3 mr-1" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clipRule="evenodd" />
                  </svg>
                  RELATED SEARCHES
                </div>
                <div className="flex flex-wrap gap-2">
                  {message.groundingData.webSearchQueries.map((query, i) => (
                    <span 
                      key={i} 
                      className={`text-xs px-3 py-1.5 rounded-full ${
                        darkMode ? 'bg-slate-800 text-slate-300' : 'bg-gray-100 text-slate-600'
                      }`}
                    >
                      {query}
                    </span>
                  ))}
                </div>
              </div>
            )}
            
            {/* Grounding supports visualization (confidence scores) */}
            {message.groundingData.groundingSupports && message.groundingData.groundingSupports.length > 0 && (
              <div className={`px-3 pt-1 pb-3 ${darkMode ? 'bg-slate-700 bg-opacity-20' : 'bg-gray-50'} rounded-b-lg`}>
                <div className="flex flex-col gap-2 mt-2">
                  {message.groundingData.groundingSupports.map((support, i) => (
                    <div key={i} className="text-xs">
                      <div className={`mb-1 ${
                        support.confidenceScores && Math.max(...support.confidenceScores) > 0.8
                          ? darkMode ? 'text-green-300' : 'text-green-600'
                          : darkMode ? 'text-yellow-300' : 'text-yellow-600'
                      }`}>
                        {support.segment?.text && (
                          <span className="font-medium">
                            {support.segment.text.length > 100 
                              ? support.segment.text.substring(0, 100) + '...' 
                              : support.segment.text}
                          </span>
                        )}
                      </div>
                      
                      {support.confidenceScores && support.confidenceScores.length > 0 && (
                        <div className="h-1.5 w-full bg-gray-300 rounded-full overflow-hidden">
                          <div 
                            className={`h-full ${
                              Math.max(...support.confidenceScores) > 0.8
                                ? 'bg-green-500' 
                                : Math.max(...support.confidenceScores) > 0.5
                                  ? 'bg-yellow-500'
                                  : 'bg-red-500'
                            }`}
                            style={{ width: `${Math.max(...support.confidenceScores) * 100}%` }}
                          ></div>
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        )}
      </motion.div>
    );
  };

  // Render a crypto card
  const renderCryptoCard = (crypto) => {
    const priceChangeIsPositive = crypto.price_change_percentage_24h > 0;
    // Prepare icon URL with proper formatting
    const iconUrl = crypto.image;
    
    return (
      <motion.div
        initial={{ opacity: 0, y: 10 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.3 }}
        className={`
          p-4 rounded-xl mb-3 flex items-center justify-between
          ${darkMode ? 'bg-slate-800 hover:bg-slate-750' : 'bg-white hover:bg-slate-50'}
          border ${darkMode ? 'border-slate-700' : 'border-slate-200'}
          transition-all duration-150 cursor-pointer
        `}
        onClick={() => {
          setInput(`Tell me about ${crypto.name} (${crypto.symbol})`);
          setActiveTab('chat');
          setTimeout(() => {
            inputRef.current?.focus();
          }, 100);
        }}
      >
        <div className="flex items-center">
          <img 
            src={iconUrl} 
            alt={crypto.name} 
            className="w-10 h-10 rounded-full mr-4"
            onError={(e) => {
              // Fallback to default icon if image fails to load
              e.target.src = `https://ui-avatars.com/api/?name=${crypto.symbol}&background=random&color=fff&size=100`;
            }}
          />
          <div>
            <div className="flex items-center">
              <h4 className={`font-medium ${darkMode ? 'text-white' : 'text-slate-800'}`}>
                {crypto.name}
              </h4>
              <span className={`text-xs ml-2 ${darkMode ? 'text-slate-400' : 'text-slate-500'}`}>
                {crypto.symbol}
              </span>
            </div>
            <div className={`text-sm ${darkMode ? 'text-slate-400' : 'text-slate-600'}`}>
              ${crypto.current_price.toLocaleString()}
            </div>
          </div>
        </div>
        <div className={`text-sm font-medium ${priceChangeIsPositive ? 'text-emerald-500' : 'text-red-500'}`}>
          {priceChangeIsPositive ? '+' : ''}{crypto.price_change_percentage_24h.toFixed(2)}%
        </div>
      </motion.div>
    );
  };

  // Render a stock card
  const renderStockCard = (stock) => {
    const changeIsPositive = parseFloat(stock.change) > 0;
    
    return (
      <motion.div
        initial={{ opacity: 0, y: 10 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.3 }}
        className={`
          p-4 rounded-xl mb-3 flex items-center justify-between
          ${darkMode ? 'bg-slate-800 hover:bg-slate-750' : 'bg-white hover:bg-slate-50'}
          border ${darkMode ? 'border-slate-700' : 'border-slate-200'}
          transition-all duration-150 cursor-pointer
        `}
        onClick={() => {
          setInput(`Tell me about ${getCompanyName(stock.symbol)} (${stock.symbol}) stock`);
          setActiveTab('chat');
          setTimeout(() => {
            inputRef.current?.focus();
          }, 100);
        }}
      >
        <div className="flex items-center">
          <div className={`w-10 h-10 rounded-full mr-4 flex items-center justify-center ${
            changeIsPositive ? 'bg-emerald-100 text-emerald-700' : 'bg-red-100 text-red-700'
          }`}>
            <span className="font-bold text-sm">{stock.symbol.substring(0, 2)}</span>
          </div>
          <div>
            <div className="flex items-center">
              <h4 className={`font-medium ${darkMode ? 'text-white' : 'text-slate-800'}`}>
                {stock.symbol}
              </h4>
              <span className={`text-xs ml-2 truncate max-w-[120px] ${darkMode ? 'text-slate-400' : 'text-slate-500'}`}>
                {getCompanyName(stock.symbol)}
              </span>
            </div>
            <div className={`text-sm ${darkMode ? 'text-slate-400' : 'text-slate-600'}`}>
              ${stock.price}
            </div>
          </div>
        </div>
        <div className={`text-sm font-medium ${changeIsPositive ? 'text-emerald-500' : 'text-red-500'}`}>
          {changeIsPositive ? '+' : ''}{stock.changePercent}%
        </div>
      </motion.div>
    );
  };

  // Render an insight card - modified to use component-level state
  const renderInsightCard = (insight) => {
    const { id, data, createdAt } = insight;
    const isComparisonChart = id.startsWith('comparison_');
    
    // Use the ID to access the corresponding state
    const showIndicatorsForThisChart = showIndicators[id] || false;
    const indicatorsForThisChart = selectedIndicators[id] || ['sma'];
    
    // Toggle indicators for a stock chart
    const toggleIndicator = (indicator) => {
      if (indicatorsForThisChart.includes(indicator)) {
        setSelectedIndicators(prev => ({
          ...prev,
          [id]: prev[id].filter(i => i !== indicator)
        }));
      } else {
        setSelectedIndicators(prev => ({
          ...prev,
          [id]: [...(prev[id] || []), indicator]
        }));
      }
    };
    
    // Regenerate chart with selected indicators
    const regenerateChartWithIndicators = () => {
      if (!data || !data.chartConfig) return;
      
      let updatedChartData;
      
      if (isComparisonChart) {
        // Extract symbols from comparison chart
        const symbols = data.series.filter(s => !s.dataKey.includes('_')).map(s => s.name);
        
        // Create custom query for intelligent chart creation
        const customQuery = `Compare ${symbols.join(' vs ')} with ${indicatorsForThisChart.join(', ')}`;
        updatedChartData = createIntelligentChart(symbols, customQuery, '1m');
      } else {
        // Extract symbol from chart title
        const symbol = data.chartConfig.title.split(' ')[0];
        
        // Create custom query for intelligent chart creation
        const customQuery = `Show ${symbol} chart with ${indicatorsForThisChart.join(', ')}`;
        updatedChartData = createIntelligentChart(symbol, customQuery, '1m');
      }
      
      // Update the chart using the chart emitter
      chartEmitter.updateChart(id, updatedChartData);
    };
    
    return (
      <motion.div
        key={id}
        initial={{ opacity: 0, y: 10 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.3 }}
        className={`
          mb-6 rounded-xl overflow-hidden 
          ${darkMode ? 'bg-slate-800 border-slate-700' : 'bg-white border-slate-200'}
          border shadow-md
        `}
      >
        <div className="p-4 border-b border-slate-200 dark:border-slate-700 flex justify-between items-center">
          <div>
            <h3 className={`font-medium ${darkMode ? 'text-white' : 'text-slate-800'}`}>
              {isComparisonChart 
                ? `Comparison: ${data.series?.filter(s => !s.dataKey.includes('_')).map(s => s.name).join(' vs ')}`
                : `${data.chartConfig?.title || 'Stock Chart'}`
              }
            </h3>
            <div className={`text-xs mt-1 ${darkMode ? 'text-slate-400' : 'text-slate-500'}`}>
              Created {new Date(createdAt).toLocaleString()}
            </div>
          </div>
          <div className="flex items-center">
            <Button 
              variant="ghost" 
              size="sm" 
              className={`h-8 w-8 p-0 rounded-full ${showIndicatorsForThisChart ? 'bg-slate-700' : ''}`}
              onClick={() => setShowIndicators(prev => ({ ...prev, [id]: !prev[id] }))}
            >
              <Layers className="h-4 w-4" />
            </Button>
          </div>
        </div>
        
        {showIndicatorsForThisChart && (
          <div className={`p-2 border-b ${darkMode ? 'bg-slate-700 border-slate-600' : 'bg-slate-100 border-slate-200'}`}>
            <div className="flex flex-wrap gap-2">
              <Button 
                variant={indicatorsForThisChart.includes('sma') ? "default" : "outline"}
                size="sm"
                onClick={() => toggleIndicator('sma')}
                className="text-xs h-7"
              >
                SMA
              </Button>
              <Button 
                variant={indicatorsForThisChart.includes('ema') ? "default" : "outline"}
                size="sm"
                onClick={() => toggleIndicator('ema')}
                className="text-xs h-7"
              >
                EMA
              </Button>
              <Button 
                variant={indicatorsForThisChart.includes('macd') ? "default" : "outline"}
                size="sm"
                onClick={() => toggleIndicator('macd')}
                className="text-xs h-7"
              >
                MACD
              </Button>
              <Button 
                variant={indicatorsForThisChart.includes('rsi') ? "default" : "outline"}
                size="sm"
                onClick={() => toggleIndicator('rsi')}
                className="text-xs h-7"
              >
                RSI
              </Button>
              <Button 
                variant="default"
                size="sm"
                onClick={regenerateChartWithIndicators}
                className="text-xs h-7 ml-auto"
              >
                Apply
              </Button>
            </div>
          </div>
        )}
        
        <div className="p-4 h-64">
          {isComparisonChart ? (
            <ComparisonChart 
              data={data.chartConfig?.data} 
              series={data.series}
              xKey={data.chartConfig?.xKey} 
              title={data.chartConfig?.title} 
              metricType={data.chartConfig?.metricType || 'Price (USD)'}
              darkMode={darkMode}
            />
          ) : (
            <Chart 
              data={data.chartConfig?.data} 
              series={data.series || [{ name: 'Price', dataKey: 'value' }]}
              xKey={data.chartConfig?.xKey} 
              yKey={data.chartConfig?.yKey} 
              title={data.chartConfig?.title} 
              darkMode={darkMode}
            />
          )}
        </div>
      </motion.div>
    );
  };

  // Tab data for navigation with enhanced icons
  const tabs = [
    { id: 'chat', label: 'Chat', icon: <MessageSquare className="h-4 w-4" /> },
    { id: 'stocks', label: 'Stocks', icon: <TrendingUp className="h-4 w-4" /> },
    { id: 'crypto', label: 'Crypto', icon: <BarChart4 className="h-4 w-4" /> },
    { id: 'insights', label: 'Insights', icon: <Lightbulb className="h-4 w-4" /> }
  ];

  // Handle input submission
  const handleSubmit = (e) => {
    if (e) e.preventDefault();
    if (!input.trim()) return;
    sendMessage();
  };

  // Initialize selectedIndicators when new charts are added
  useEffect(() => {
    // Make sure each insight has a corresponding entry in the indicators state
    insights.forEach(insight => {
      if (!selectedIndicators[insight.id]) {
        setSelectedIndicators(prev => ({
          ...prev,
          [insight.id]: ['sma']
        }));
      }
    });
  }, [insights]);

  // Handle search form submission
  const handleSearchSubmit = (e) => {
    e.preventDefault();
    if (!searchInput.trim()) return;
    setInput(searchInput);
    setSearchInput('');
    setActiveTab('chat');
    // Close search UI
    setShowSearch(false);
    // Auto-submit the search
    setTimeout(() => sendMessage(), 300);
  };

  // Add CSS styles for message content formatting to the component
  useEffect(() => {
    // Create and append style element for message content
    const styleEl = document.createElement('style');
    styleEl.innerHTML = `
      .message-content a { color: #60a5fa; text-decoration: underline; }
      .message-content a:hover { text-decoration: none; }
      .message-content code { font-family: monospace; }
      .message-content ul { list-style-type: none; margin-left: 1rem; }
      .message-content li { margin-bottom: 0.25rem; }
      .message-content p { margin-bottom: 0.75rem; }
      .message-content strong { font-weight: 600; }
    `;
    document.head.appendChild(styleEl);
    
    // Clean up styles on unmount
    return () => {
      document.head.removeChild(styleEl);
    };
  }, []);

  return (
    <>
      <div className="fixed top-3 left-1/2 transform -translate-x-1/2 z-[100]">
        <motion.div
          initial="initial"
          whileHover="hover"
          whileTap="tap"
          variants={buttonVariants}
        >
          <Button
            variant="outline"
            onClick={() => setIsOpen(!isOpen)}
            className={`
              ${darkMode ? 'bg-slate-800 border-slate-700 hover:bg-slate-700' : 'bg-white border-slate-200 hover:bg-slate-50'} 
              rounded-full px-4 py-2 flex items-center gap-2 shadow-md
              transition-all duration-500 h-auto
            `}
          >
            {isOpen ? (
              <X className="h-4 w-4" />
            ) : (
              <>
                <MessageSquare className={`h-4 w-4 ${darkMode ? 'text-emerald-400' : 'text-emerald-600'}`} />
                <span className="text-sm font-medium">Portfolio Assistant</span>
              </>
            )}
          </Button>
        </motion.div>
      </div>
      
      <AnimatePresence>
        {isOpen && (
          <motion.div
            className="fixed top-16 left-1/2 transform -translate-x-1/2 z-[101]"
            variants={containerVariants}
            initial="hidden"
            animate="visible"
            exit="exit"
          >
            <motion.div 
              className={`
                rounded-2xl shadow-xl overflow-hidden w-[450px] h-[650px] flex flex-col
                border transition-colors duration-500
              `}
              animate={{
                backgroundColor: darkMode ? 'rgb(15, 23, 42)' : 'rgb(255, 255, 255)',
                borderColor: darkMode ? 'rgb(51, 65, 85)' : 'rgb(226, 232, 240)'
              }}
            >
              {/* Chat header */}
              <motion.div 
                className={`
                  px-5 py-4 border-b flex items-center justify-between
                `}
                animate={{
                  backgroundColor: darkMode ? 'rgb(30, 41, 59)' : 'rgb(248, 250, 252)',
                  borderColor: darkMode ? 'rgb(51, 65, 85)' : 'rgb(226, 232, 240)'
                }}
              >
                <h3 className={`font-semibold transition-colors duration-300 ${darkMode ? 'text-white' : 'text-slate-800'}`}>
                  TrackVest AI Assistant
                </h3>
                <div className="flex items-center space-x-2">
                  <Button 
                    variant={webSearchEnabled ? "default" : "ghost"}
                    size="sm" 
                    className={`h-8 p-0 px-2 rounded-full text-xs flex items-center ${
                      webSearchEnabled ? 
                        (darkMode ? "bg-emerald-600 text-white" : "bg-emerald-500 text-white") : 
                        ""
                    }`}
                    onClick={() => setWebSearchEnabled(!webSearchEnabled)}
                  >
                    <Zap className="h-3 w-3 mr-1" />
                    {webSearchEnabled ? "Web Search: ON" : "Web Search"}
                  </Button>
                  <Button 
                    variant="ghost" 
                    size="sm" 
                    className="h-8 w-8 p-0 rounded-full"
                    onClick={() => setShowSearch(!showSearch)}
                  >
                    <Search className="h-4 w-4" />
                  </Button>
